# chapter 18

## 01. 切片与`append`函数
### 正经版：

&emsp;**切片的结构**：切片由指向底层数组的指针、长度（当前元素数量）和容量（底层数组可容纳的最大元素数）组成。

&emsp;**`append`函数**：用于向切片追加元素。若容量不足，会分配新数组（容量通常翻倍），并复制旧数据。
```go
s := []int{1, 2}
s = append(s, 3)        // 追加单个元素
s = append(s, 4, 5, 6)  // 追加多个元素
```

&emsp;扩容示例：
```go
s := make([]int, 0, 2) // len=0, cap=2
s = append(s, 1, 2)    // len=2, cap=2
s = append(s, 3)       // len=3, cap=4（容量翻倍）
```

### 大白话版：

&emsp; **切片（Slice）就是个“能变大的书包”**

&emsp;&emsp;**书包结构**：

&emsp;&emsp;&emsp;**容量**：书包最多能装多少东西（比如能装5本书）。

&emsp;&emsp;&emsp;**长度**：书包现在装了多少东西（比如装了3本书）。

&emsp;&emsp;&emsp;**底层数组**：书包本身，装东西的地方。

&emsp;&emsp;**`append`函数**：往书包里塞东西，如果塞满了，就换个更大的书包（容量翻倍），然后把旧书包的东西倒进去。
```go
书包 := []int{苹果, 香蕉}  
书包 = append(书包, 橙子)      // 塞一个橙子进去  
书包 = append(书包, 葡萄, 西瓜) // 塞多个水果  
```

&emsp;&emsp;示例：
原本书包能装2个水果，再塞第3个时，书包会变成能装4个的新书包。

## 02. 三索引切片
### 正经版：

&emsp;**语法**：**`s[low:high:max]`**，限制新切片的容量为 **`max - low`**。
```go
arr := [5]int{1, 2, 3, 4, 5}
s := arr[1:3:4] // len=2（3-1），cap=3（4-1）
```

&emsp;&emsp;**作用**：防止新切片覆盖底层数组的其他部分。若对 **`s`** 追加元素超出容量，会触发新数组分配，不再影响原 **`arr`**。

### 大白话版：

&emsp; **三索引切片：给书包加个“隔层”**

&emsp;&emsp;**作用**：防止你往书包里塞东西时，不小心把隔壁的东西弄乱。
```go
原始书包 := [5]int{1,2,3,4,5}  
新书包 := 原始书包[1:3:4]  // 从第2个到第4个位置，但最多只能装3个东西  
```

&emsp;&emsp;&emsp;*结果*：新书包只能装3个东西（容量限制），如果塞第4个，系统会强制换新书包，不影响原来的书包。

## 03. make函数预分配
### 正经版：

&emsp;**用法**：**`make([]T, length, capacity)`**，可指定长度和容量。
```go
s := make([]int, 3, 10) // len=3（初始化为0），cap=10
```

&emsp;**优势**：预分配足够容量可减少扩容次数，提升性能。

### 大白话版：

&emsp; **`make`函数：提前准备个大书包**

&emsp;&emsp;**用法**：提前告诉系统：“我要一个能装10本书的书包，但现在只放3本进去。”
```go
书包 := make([]int, 3, 10) // 现在有3本（初始为0），最多能装10本  
```

&emsp;&emsp;&emsp;**好处**：不用频繁换书包，省时间。

## 04. 可变参数函数
### 正经版：

&emsp;**定义**：在最后一个参数类型前加 **`...`**，表示接受不定数量参数。
```go
func sum(nums ...int) int {
    total := 0
    for _, n := range nums {
        total += n
    }
    return total
}
```

&emsp;**调用**：用 **`slice...`** 展开切片。
```go
s := []int{1, 2, 3}
fmt.Println(sum(s...)) // 输出6
```

### 大白话版：

&emsp; **可变参数函数：能装“随便多少东西”的函数**

&emsp;&emsp;**定义**：函数可以接受“随便多少个参数”，比如超市收银员能扫任意数量的商品。
```go
func 结账(商品 ...int) int {  
    总价 := 0  
    for _, 价格 := range 商品 {  
        总价 += 价格  
    }  
    return 总价  
}  
```

&emsp;&emsp;**调用**：可以把一袋子水果一次性倒进去算钱：
```go
水果价格 := []int{5, 3, 8}  
结账(水果价格...) // 输出16元  
```

## 总结

|概念|说明|
|:-----:|:-----:|
|切片长度（**`len`**）|当前存储的元素数量。|
|切片容量（**`cap`**）|底层数组可容纳的最大元素数。|
|**`append`** 扩容策略|容量不足时，分配新数组（通常为原容量的2倍）。|
|三索引切片|通过限制容量，避免意外覆盖底层数组。|
| **`make`** 预分配|减少扩容开销，提升性能。|
|可变参数函数|使用 **`...`** 定义和调用，灵活处理不定数量参数。|
