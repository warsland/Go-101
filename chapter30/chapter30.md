# chapter 30

## 01. Goroutine：轻量级并发单元
### 正经版：

&emsp;**Goroutine** 是Go语言中独立运行的轻量级线程，由Go运行时管理，创建开销极小。

&emsp;**启动方式**：在函数调用前添加 `go` 关键字
```go
func myTask() {
    // 任务逻辑
}

func main() {
    go myTask()  // 在新goroutine中运行
    go func() {  // 匿名函数启动
        // 任务逻辑 
    }()
}
```

&emsp;**核心特性**：
*   高效创建（比系统线程开销低数个量级）
*   无序执行（计算机使用分时技术，**执行顺序无法保证**）
*   参数传递（函数参数会被复制传递，与原值独立）

## 02. Channel：Goroutine间安全通信
### 正经版：

&emsp;**Channel（通道）** 是类型化管道，用于在Goroutine间**安全传递数据**。通道可像普通变量一样传递和存储。

&emsp;**创建通道**：使用 `make` 并指定元素类型
```go
ch := make(chan int)      // 无缓冲int通道
msgCh := make(chan string) // 无缓冲string通道
bufCh := make(chan bool, 3) // 容量为3的缓冲bool通道
```

## 03. 通道操作：发送与接收
### 正经版：

&emsp;使用左箭头操作符 `<-` 进行发送/接收：

&emsp;**发送数据**（通道在左侧，阻塞直到接收）：
```go
ch <- 42 // 发送整型42到通道ch
```

&emsp;**接收数据**（通道在右侧，阻塞直到发送）：
```go
value := <-ch   // 从ch接收值并赋值
<-ch            // 接收但丢弃值（常用于同步）
```

&emsp;**通道接收可嵌入表达式**：
```go
fmt.Println(<-ch * 2) // 接收值并立即计算
```

## 04. 通道阻塞与死锁
### 正经版：

&emsp;**阻塞**：Goroutine因等待通道操作（发送/接收）而暂停执行。

&emsp;**死锁**：所有Goroutine均因**无法满足的条件**而永久阻塞（Go运行时检测并崩溃）。

&emsp;**示例死锁场景**：
```go
func main() {
    ch := make(chan int)
    ch <- 5   // 发送阻塞（无接收者）
    fmt.Println(<-ch) // 永不会执行
} // 报错: fatal error: all goroutines are asleep - deadlock!
```

## 05. 通道关闭与检测
### 正经版：

&emsp;使用 `close()` 关闭通道，表示不再发送值。

&emsp;**关键规则**：
1.  关闭后发送数据 → 引发 `panic`
2.  关闭后接收数据 → 返回通道类型的零值（如 `int` 为 `0`, `string` 为 `""`）
3.  **必须检查关闭**，避免读取零值误判

&emsp;**安全检测关闭**：
```go
v, ok := <-ch
if !ok {
    fmt.Println("通道已关闭") // ok为false表示关闭
}
```

&emsp;**循环通道必须检测关闭**：
```go
for {
    v, ok := <-ch
    if !ok {
        break // 退出循环
    }
    // 处理v
}

// 或使用range（自动检测关闭）
for v := range ch {
    // 处理v 
} // 当ch关闭时自动退出
```

## 06. `select` 语句：多路通道操作
### 正经版：

&emsp;`select` 监听多个通道操作，执行**首个就绪**的 `case`：

&emsp;**基本结构**：
```go
select {
case v := <-ch1:   // 接收ch1
    fmt.Println("ch1:", v)
case ch2 <- "data": // 发送到ch2
    fmt.Println("Sent to ch2")
case <-time.After(2 * time.Second): // 超时控制
    fmt.Println("Timeout!")
default:             // 无通道就绪时执行
    fmt.Println("No activity")
}
```

&emsp;**重要用途**：

*   **超时控制**：`time.After()` 返回定时通道

*   **永久等待**：`select{}` 阻止 `main` 退出（用于后台Goroutine）

*   **多通道响应**：同时监听多个事件源

## 07. Goroutine 生命周期管理
### 正经版：

&emsp;**关键问题**：

*   **内存泄漏**：主函数退出后，未完成的Goroutine仍占用资源

*   **超时控制**：避免Goroutine无限期阻塞

&emsp;**解决方案**：

1.  使用 `context` 包传递取消信号（进阶内容）

2.  结合 `select` 和 `time.After()` 实现超时：

```go
func worker(resultChan chan int) {
    // 模拟耗时任务
    time.Sleep(3 * time.Second)
    resultChan <- 42
}

func main() {
    resCh := make(chan int)
    go worker(resCh)

    select {
    case res := <-resCh:
        fmt.Println("Result:", res)
    case <-time.After(1 * time.Second): // 1秒超时
        fmt.Println("Timeout!") 
    }
}
```

## 设计哲学：通信顺序进程（CSP）

&emsp;Go并发模型的核心思想：

> **"Do not communicate by sharing memory; instead, share memory by communicating."**  

> **（不要通过共享内存来通信；而应通过通信来共享内存。）**

*   **Goroutine**：独立执行的并发单元

*   **Channel**：Goroutine间通信的管道（替代显式锁）

*   通过组合二者，构建安全、清晰的并发程序

---

&emsp;**关键总结**：

1.  `go` 关键字启动Goroutine（非阻塞）

2.  Channel是Goroutine间通信的**唯一推荐方式**

3.  通道操作默认**阻塞**，需配合 `select` 或超时

4.  **必须显式关闭**不再使用的通道（避免接收死循环）

5.  主函数退出会终止所有Goroutine，注意资源释放

## 大白话版：

### 1. **Goroutine（高揉替）**：就是**“后台小工”**
*   **干啥的？** 让你的程序能同时干多件事（比如一边下载文件一边响应用户点击）。
*   **怎么用？** 在普通函数调用前加个 `go`：
    ```go
    go 下载文件()  // 喊个小工去后台下载
    go 播放音乐()  // 再喊个小工去播放音乐
    ```
*   **特点：**
    *   **超便宜：** 雇1个小工和雇1000个小工，老板（电脑）压力不大。
    *   **各干各的：** 你**不知道**哪个小工会先干完活，他们的工作顺序是乱的。
    *   **自带工具包：** 你给小工时传递的工具（参数），他会自己复制一份用，不影响你手里的。

---

### 2. **Channel（禅闹）**：就是**“传送带”**
*   **为啥需要？** 小工们（Goroutine）之间要**安全地传递东西**（数据），或者**喊一声“我干完了”**（协调）。
*   **怎么造传送带？**
    ```go
    快递带 := make(chan 包裹)  // 造一条专门传“包裹”（某种类型数据）的传送带
    ```
*   **怎么用传送带？**
    *   **小工A送货（发送）：** `快递带 <- 我的包裹`
        *   **关键：** 如果没人来收（接收），小工A就抱着包裹在传送带旁**傻等**（阻塞），啥也干不了，直到小工B来收货。
    *   **小工B收货（接收）：** `收到的包裹 := <-快递带`
        *   **关键：** 如果传送带上没货（没数据），小工B就在传送带旁**干等**（阻塞），直到小工A把货送来。
*   **传送带很灵活：** 可以把它当普通东西用：存起来、传给别的函数、放进工具箱（结构体）里。

---

### 3. **高级技巧 & 常见坑**

*   **等一群小工交活：** 搞一条传送带，让所有小工都把结果（包裹）放上来。老板（主Goroutine）就在带子尽头收包裹就行。

*   **防止小工磨洋工 - 超时：**
    ```go
    等2秒 := time.After(2 * time.Second) // 搞个定时炸弹，2秒后“砰”一下（返回个通道信号）
    
    select {
    case 包裹 := <-快递带:  // 尝试收包裹
        fmt.Println("收到货啦！", 包裹)
    case <-等2秒:         // 2秒到了还没收到？
        fmt.Println("超时了！不等了！") // 引爆定时炸弹，走人
    }
    ```

*   **`select` - 多路监听器：**
    *   老板（程序）可以**同时盯好几条传送带**（或定时炸弹）。
    *   哪条传送带**先有动静**（有货送来/有人收货/定时到点），老板就**先处理哪条**。
    *   `select {}` 就是老板坐那发呆，啥也不干，**永远等下去**（除非你关程序）。

*   **关传送带 (`close`)：**
    *   老板喊：`close(快递带)` （关传送带！）
    *   **关之后：**
        *   小工再想送货？**不行！** 会炸锅 (`panic`)。
        *   传送带上**剩下的货**还能收完。
        *   货收完后，再收货会**立刻拿到“空气”**（对应类型的零值，比如数字是0，字符串是空""）。

*   **检查传送带关了没？**
    ```go
    包裹, 还有货吗 := <-快递带
    if !还有货吗 { // 如果“还有货吗”是false
        fmt.Println("传送带关了且没货了！")
    } else {
        fmt.Println("收到包裹：", 包裹)
    }
    ```

*   **循环收快递的坑：**
    ```go
    for 包裹 := range 快递带 { // 一直收，直到...
        fmt.Println(包裹)
    }
    ```
    *   **大坑！** 如果传送带**永远不关**，也没人再送货，这个循环就**卡死在这**了！小工（Goroutine）永远等，浪费资源（内存泄露）。

*   **死锁：** 所有小工都**卡住了**！
    *   例子：小工A等小工B收货，小工B等小工A送货...结果俩人都在**干等对方先动**，程序僵死。Go会报错 `死锁啦！`

*   **小工泄露：** 你（主程序）干完活走了，但有个傻小工还在**空等**永远不来的货（或被永远不关的循环卡住）。他没活干又不下班（不退出），白占公司资源（内存、CPU调度）。

---

**一句话总结干活流程：**

1.  **雇小工：** `go 干活()` 启动后台任务。
2.  **传东西/通知：** 用 `传送带 <- 数据` 和 `数据 := <-传送带` 让小工间安全协作。
3.  **防卡死：**
    *   用 `select` + `time.After` **设超时**。
    *   活干完了记得 `close(传送带)` 通知收工。
    *   循环收快递 `for range` 时，**一定确保**有人会关传送带。
4.  **防泄露：** 确保每个小工最终**都有办法退出**（收到关闭信号、超时、活干完）。