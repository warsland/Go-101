在Go中，独立运行的任务被称为goroutine。其创建效率非常高，且Go可以直接了当地协同多个并发操作。

启动goroutine需要在调用前添加关键字go。

每一次使用go关键字都会产生一个新的goroutine，计算机会在处理时采用分时技术。所以在使用goroutine时，应假设所有goroutine中的各项操作会以任意顺序执行。

goroutine可以传递实参，并像函数一样，传入的值被复制并以形参的方式传递。

通道(channel)可以在多个goroutine之间安全传递值，并且可以将通道作为变量、传递至函数、存储在结构中等其他类型可以做到的事情。

创建通道与创建映射或切片相同，需要使用到内置的make函数，并且需要在创建时指定其相应的类型。

在完成通道的创建后，可以使用左箭头操作符（<-）向其发送或接受数值。

在向通道发送至的时候，将通道表达式放在左箭头操作符的左侧，待发送的值放在左箭头操作符的右侧。发送操作会等待直至另一个goroutine尝试对相同的通道直到接收操作为止。期间执行发送操作的goroutine无法执行其他操作。
>c <- 99

在通过通道接收值的时候，通道位于左箭头操作符右侧，箭头指向其他位置。执行接收操作的goroutine将等待至另一个goroutine尝试向相同的通道执行发送操作为止。
>r :=<- c

通道的接收操作可以应用在任何能够使用表达式的地方。

单个通道等待多个goroutine，并在所有goroutine产生相同类型的值的时候方便使用。

time.After函数可以返回一个通道，该通道将在啊经过特定时间后收到一个值。可以使用此函数来创建一个超时通道。

select语句包含每个case分支都持有一个针对通道的接收或发送操作。select会等待某个分支操作就绪，然后执行该操作及其关联的分支语句。

select语句在不包含任何分支的情况下会永远等待下去。在启动多个goroutine并且打算使其无限运行时，可以使用此种方法阻止main函数返回。

将动作放入goroutine并在动作完成时执行返回操作，可以在Go中的任何动作都设置超时，从而控制事件完成的时间。

即使程序停止等待goroutine，但是只要主程序尚未结束，仍在运行的goroutine就会继续占用内存。

阻塞：goroutine在等待通道的发送或接收操作。

死锁：一个或者多个goroutine因为某些永远无法发生的事情被阻塞。

Go允许在没有值可以发送的情况下使用close函数关闭通道，通道被关闭后无法写入任何值，写入操作会引起惊恐。

尝试读取已被关闭的通道会获得一个与通道类型对饮的零值。

在循坏内读取一个已经关闭的通道并且没有检查通道是否关闭，会导致程序进入死循环。

>v,ok:=<-c
该代码可以检查通道是否关闭，如果第二个变量的值为false,则通道已被关闭。