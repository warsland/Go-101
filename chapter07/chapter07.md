# chapter07

## 01. 整数类型分类
### 正经版：

&emsp;Go提供5种有符号整数类型（**`int8`**, **`int16`**, **`int32`**, **`int64`**, **`int`**）和5种无符号整数类型（**`uint8`**, **`uint16`**, **`uint32`**, **`uint64`**, **`uint`**）。

&emsp;类型名称中的数字表示位数，如 **`int8`**占8位（1字节）， **`int64`**占64位（8字节）。

&emsp;取值范围由位数决定，例如：

&emsp;&emsp;·**`int8`**：-128 ~ 127

&emsp;&emsp;·**`uint8`**：0 ~ 255

&emsp;&emsp;·**`int64`**：-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807

### 大白话版：

&emsp;**整数类型就是“数字的盒子”**

&emsp;&emsp;Go语言里的整数类型就像不同大小的盒子，有的能装正负数，有的只能装正数：

&emsp;&emsp;&emsp;有符号的盒子（能装正负）：**`int8`**, **`int16`**, **`int32`**, **`int64`**, **`int`**

&emsp;&emsp;&emsp;&emsp;比如 **`int8`** 是一个小盒子，只能装-128到127，装多了会“炸”。

&emsp;&emsp;&emsp;无符号的盒子（只能装正数）：**`uint8`**, **`uint16`**, **`uint32`**, **`uint64`**, **`uint`**

&emsp;&emsp;&emsp;&emsp;比如 **`uint8`** 只能装0到255，适合存颜色值（比如RGB中的红绿蓝）。

&emsp;&emsp;记不住数字范围？看名字！
&emsp;&emsp;名字里的数字就是盒子的“位数”，位数越大，能装的数字越多。比如：

&emsp;&emsp;&emsp;·**`int8`**：8位 → 小盒子（装-128~127）

&emsp;&emsp;&emsp;·**`int64`**：64位 → 超大盒子（装超级大的数）

## 02. 默认类型 int
### 正经版：

&emsp;Go的默认整数类型是 **`int`**，其大小取决于操作系统（32位系统为4字节，64位系统为8字节）。

&emsp;如果变量值在 **`int`** 范围内，无需显式指定类型，直接使用类型推断即可。

&emsp;若需处理超大整数（如文件大小、时间戳），应显式使用 **`int64`** 或 **`uint64`**。

### 大白话版：

&emsp;**默认用`int`，省事！**
&emsp;&emsp;如果不写类型，Go会默认用 **`int`**。它的大小和你的电脑系统有关（32位系统用4字节，64位用8字节）。

&emsp;&emsp;例子：
```go
age := 25   // Go自动认为是int类型，不用纠结！
```

## 03.适用场景
### 正经版：

&emsp;· **`uint8`**：适合表示颜色（RGB值范围为0~255）、像素数据等。

&emsp;· **`int32`**/ **`int64`**：适合需要大范围整数的场景（如金融计算）。

&emsp;· **`uint`**：表示非负整数时优先使用（如计数器）。

### 大白话版：

&emsp;**什么时候选什么盒子？**

&emsp;&emsp;· **小数字**：比如颜色值（0~255），用 **`uint8`**，省内存。

&emsp;&emsp;· **超大数字**：比如存宇宙的星星数量，用 **`int64`** 或 **`uint64`**。

&emsp;&emsp;· **避免盒子炸了**：如果数字超过盒子容量，会“回绕”（比如 **`uint8`** 装256会变0）。

## 04. 十六进制与二进制
### 正经版：

&emsp;**十六进制**：必须以 **`0x`** 或 **`0X`** 开头，例如 **`0xFF`**。

&emsp;&emsp;·**格式化输出**：**`fmt.Printf("%x", 255)`** → **`ff`**，**`%X`**输出大写（**`FF`**）。

&emsp;&emsp;·**零填充**：**`fmt.Printf("%04X", 15)`** → **`000F`**（输出4位，不足补零）。

&emsp;**二进制**：使用 **`%b`** 格式化输出，例如：
```go
fmt.Printf("%08b", 15) // 输出：00001111（8位，补零）
```

### 大白话版：

&emsp;**十六进制和二进制怎么用？**

&emsp;&emsp;**十六进制**（比如颜色代码）：

&emsp;&emsp;&emsp;Go中要写 **`0x`** 开头，比如 **`0xFF`** 代表红色。

&emsp;&emsp;&emsp;打印时用 **`%x`**（小写）或 **`%X`**（大写）：
```go
fmt.Printf("%X", 255) // 输出FF
```

&emsp;&emsp;**二进制**：用 **`%b`** 打印，还能补零：
```go
fmt.Printf("%08b", 15) // 输出00001111（补够8位）
```

## 05. 整数回绕（溢出）

&emsp;·当值超出类型范围时，会“回绕”到最小值：

&emsp;&emsp;**`uint8`** 变量赋值为256 → 回绕为0。

&emsp;&emsp;**`int8`** 变量赋值为128 → 回绕为-128。

&emsp;·**解决方法**：选择足够大的类型（如用 **`uint16`** 代替 **`uint8`** ），或用`math`包的常量检查范围（如`math.MaxUint16`）。

## 06.示例代码：

```go
package main

import (
	"fmt"
	"math"
)

func main() {
	var color uint8 = 255          // 颜色值（0~255）
	var bigNumber int64 = math.MaxInt64 // 大整数
	hexValue := 0xFF              // 十六进制
	fmt.Printf("颜色：%d，十六进制：%#X\n", color, hexValue)
	fmt.Printf("二进制：%08b\n", 15)   // 输出：00001111
	fmt.Println("uint16最大值：", math.MaxUint16) // 输出：65535
}
```

## 总结：
- **选型原则**：根据值的范围选择最小够用的类型（节省内存）。
- **避免回绕**：用math包常量（如 **`math.MaxUint16`** ）辅助检查范围。
- **格式化输出**：**`%x`**、**`%X`**、**`%b`**结合零填充功能，灵活控制输出格式。