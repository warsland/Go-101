# chapter 06

## 01. 变量类型与浮点数
### 正经版：

&emsp;**变量类型**：每个变量在Go中都有类型，比如整数用int，小数用float。

&emsp;为什么需要类型？类型决定了变量能存储的数据形式和占用的内存大小。

&emsp;声明浮点变量：
```go
var a float64 = 3.14  // 显式声明为float64
b := 3.14             // 编译器自动推断为float64（默认）
```

### 大白话版

&emsp;**浮点数是啥？**

&emsp;就是带小数点的数，比如 `3.14`、`0.5`。

&emsp;Go 里浮点数分两种：**`float32`**（小杯子装水）和 **`float64`**（大杯子装水）。

&emsp;&emsp;**默认用大杯子（float64）**：精度高，能存更多小数位。

&emsp;&emsp;**小杯子（float32）**：省内存，但装水少（精度低），用的时候要明说。

## 02. 默认类型：float64
### 正经版：

&emsp;所有带小数点的数（如`3.14`）默认是 **`float64`**，占8字节内存，精度高。

&emsp;如果想用 **`float32`**（占4字节，精度低），必须显式指定：
```go
var c float32 = 3.14  // 明确声明为float32
``` 

### 大白话版

&emsp;**怎么声明浮点数？**

&emsp;&emsp;直接写小数，默认是float64：
```go
a := 3.14   // 自动是float64
```

&emsp;&emsp;想用float32，必须明说：
```go
var b float32 = 3.14  // 手动指定用小杯子
```

## 03. 整数初始化浮点变量
### 正经版：

&emsp;如果用整数初始化浮点变量，必须显式指定类型：
```go
var d float32 = 5     // 正确：5会被转为5.0（float32）
e := 5                // 错误！e会是int类型，不是浮点数
```

### 大白话版

&emsp;**整数能当浮点数用吗？**

&emsp;&emsp;可以，但要加小数点或明说类型：
```go
c := 5      // 这是整数（int），不是浮点数！
d := 5.0    // 这是float64
var e float32 = 5  // 强制转成float32（其实是5.0）
```

## 04. float32 vs float64
### 正经版：

&emsp;·**`float32`**：省内存，但精度低（只能保留约6位小数）。

&emsp;·**`float64`**：占内存多，但精度高（约15位小数），是Go的默认选择。

&emsp;示例：
```go
var f float32 = 123.456789  // 实际可能存储为123.45679（精度丢失）
var g float64 = 123.456789  // 存储更精确
```

## 05. math包与浮点类型
### 正经版：

&emsp;Go的`math`包函数（如`math.Sqrt`）只接受 **`float64`**：

```go
x := 16.0
y := math.Sqrt(x)  // 正确：x是float64
var z float32 = 9
// math.Sqrt(z)    // 错误！需要float64
```

## 06. 变量的零值
### 正经版：

&emsp;未赋值的浮点变量默认是 **`0.0`**：

```go
var h float64
fmt.Println(h)  // 输出 0
```

### 大白话版

&emsp;**浮点数的默认值（零值）**

&emsp;&emsp;没赋值时，默认是0：

```go
var x float64
fmt.Println(x) // 输出 0
```

## 07. 格式化输出：控制小数位数
### 正经版：

&emsp;用 **`Printf`**的 **`%f`**格式化：

```go
num := 3.1415926
fmt.Printf("默认：%f\n", num)        // 3.141593（默认6位小数）
fmt.Printf("两位小数：%.2f\n", num)  // 3.14
fmt.Printf("宽度10，两位小数：%10.2f\n", num) // 输出："      3.14"（左侧填充空格）
fmt.Printf("0填充：%010.2f\n", num)  // 输出：0000003.14
```

### 大白话版

&emsp;**打印浮点数（控制小数位数）**

&emsp;&emsp;用 **`Printf`**的 **`%f`**：

```go
num := 3.1415926
fmt.Printf("默认打印：%f → 3.141593\n", num)      // 默认6位小数
fmt.Printf("保留两位：%.2f → 3.14\n", num)        // 两位小数
fmt.Printf("占10个位置：%10.2f → [    3.14]\n", num) // 左侧补空格
fmt.Printf("补0：%010.2f → 000003.14\n", num)     // 左侧补0
```

## 08. 浮点数的精度问题
### 正经版：

&emsp;**问题根源**：二进制无法精确表示某些十进制小数（如0.1）。

&emsp;示例：
```go
fmt.Println(0.1 + 0.2) // 输出0.30000000000000004（不是精确0.3）
```
&emsp;**解决方案**：

&emsp;&emsp;·需要精确计算时（如金钱），用整数（单位是分）或 **`decimal`**库。

&emsp;&emsp;运算顺序优化：先乘后除可能减少误差：

```go
// 不推荐：可能误差大
result1 := (a / b) * c

// 推荐：先乘后除
result2 := (a * c) / b
```

### 大白话版

&emsp;**精度问题（为啥0.1+0.2≠0.3？）**

&emsp;&emsp;**计算机用二进制存小数，有些数存不准**，比如 `0.1` 存进去会变近似值。

```go
fmt.Println(0.1 + 0.2) // 输出 0.30000000000000004
```

&emsp;&emsp;怎么办：

&emsp;&emsp;&emsp;需要精确计算（比如算钱），别用浮点数！改用整数（单位用分）或专门库（如 **`decimal`**）。

&emsp;&emsp;&emsp;先乘后除，误差更小：

```go
// 不推荐：可能误差大
结果1 := (a / b) * c

// 推荐：先乘后除更准
结果2 := (a * c) / b
```

## 总结

### 表格

| 概念 | 要点 |
|:-------:|:--------:| 
| 默认浮点类型 | 小数默认是 **`float64`**，显式声明才能用 **`float32`** |
| 类型推断 | **`x := 3.14`** → **`x`**是 **`float64`** |
| 零值 | 未赋值的浮点变量初始为 **`0.0`** |
| 格式化输出 | **`%.2f`**保留两位小数，**`%10.2f`**控制宽度和填充 |
| 精度问题 | 避免用浮点做精确计算，优先用 **`float64`**，注意运算顺序 |

### 一句话总结

- 能用 **`float64`**就别用 **`float32`**（除非省内存很重要）。
- 打印小数用 **`%.2f`**，想补空格或0就加数字（如 **`%10.2f`**）。
- 别用浮点数算钱！会丢钱！
